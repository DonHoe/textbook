import{_ as e,c as a,o,N as t}from"./chunks/framework.d71a89c9.js";const r="/textbook/lock-mind.jpg",f=JSON.parse('{"title":"多线程","description":"","frontmatter":{},"headers":[],"relativePath":"chapter/code/thread/synchronized.md"}'),i={name:"chapter/code/thread/synchronized.md"},n=t('<h1 id="多线程" tabindex="-1">多线程 <a class="header-anchor" href="#多线程" aria-label="Permalink to &quot;多线程&quot;">​</a></h1><p><img src="'+r+`" alt="An image"></p><h2 id="volatile" tabindex="-1">volatile <a class="header-anchor" href="#volatile" aria-label="Permalink to &quot;volatile&quot;">​</a></h2><ol><li>数据发生更改后，立即从缓存回写到内存</li><li>回写操作会使得其他处理器的缓存无效</li></ol><h2 id="synchronized" tabindex="-1">synchronized <a class="header-anchor" href="#synchronized" aria-label="Permalink to &quot;synchronized&quot;">​</a></h2><pre><code>核心就是争夺monitor对象的所有权,monitorenter进入数+1,monitorexit进入数-1,直到为0。才可以被其他线程持有。  
synchronized方法上会有一个特殊的标志位ACC_SYNCHRONIZED，会隐式调用上述两个指令
</code></pre><h4 id="用法" tabindex="-1">用法: <a class="header-anchor" href="#用法" aria-label="Permalink to &quot;用法:&quot;">​</a></h4><ul><li>普通方法，锁当前实例</li><li>静态方法，锁当前类</li><li>代码块，锁括号里面的对象</li></ul><h4 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h4>`,9),l=[n];function c(d,h,s,_,m,p){return o(),a("div",null,l)}const b=e(i,[["render",c]]);export{f as __pageData,b as default};
