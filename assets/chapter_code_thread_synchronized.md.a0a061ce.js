import{_ as e,c as a,o as i,b as r}from"./app.a6c93100.js";const n="/textbook/lock-mind.jpg",f=JSON.parse('{"title":"多线程","description":"","frontmatter":{},"headers":[{"level":2,"title":"volatile","slug":"volatile","link":"#volatile","children":[]},{"level":2,"title":"synchronized","slug":"synchronized","link":"#synchronized","children":[]}],"relativePath":"chapter/code/thread/synchronized.md"}'),t={name:"chapter/code/thread/synchronized.md"},o=r('<h1 id="多线程" tabindex="-1">多线程 <a class="header-anchor" href="#多线程" aria-hidden="true">#</a></h1><p><img src="'+n+`" alt="An image"></p><h2 id="volatile" tabindex="-1">volatile <a class="header-anchor" href="#volatile" aria-hidden="true">#</a></h2><ol><li>数据发生更改后，立即从缓存回写到内存</li><li>回写操作会使得其他处理器的缓存无效</li></ol><h2 id="synchronized" tabindex="-1">synchronized <a class="header-anchor" href="#synchronized" aria-hidden="true">#</a></h2><pre><code>核心就是争夺monitor对象的所有权,monitorenter进入数+1,monitorexit进入数-1,直到为0。才可以被其他线程持有。  
synchronized方法上会有一个特殊的标志位ACC_SYNCHRONIZED，会隐式调用上述两个指令
</code></pre><h4 id="用法" tabindex="-1">用法: <a class="header-anchor" href="#用法" aria-hidden="true">#</a></h4><ul><li>普通方法，锁当前实例</li><li>静态方法，锁当前类</li><li>代码块，锁括号里面的对象</li></ul><h4 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h4>`,9),d=[o];function l(h,c,s,_,p,m){return i(),a("div",null,d)}const v=e(t,[["render",l]]);export{f as __pageData,v as default};
