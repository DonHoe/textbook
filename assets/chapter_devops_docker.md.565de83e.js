import{_ as s,c as l,o as n,b as a}from"./app.80aae63d.js";const D=JSON.parse('{"title":"docker","description":"","frontmatter":{},"headers":[{"level":3,"title":"命令","slug":"命令","link":"#命令","children":[]},{"level":3,"title":"run参数","slug":"run参数","link":"#run参数","children":[]},{"level":3,"title":"Dockerfile文件","slug":"dockerfile文件","link":"#dockerfile文件","children":[]}],"relativePath":"chapter/devops/docker.md"}'),e={name:"chapter/devops/docker.md"},o=a(`<h1 id="docker" tabindex="-1">docker <a class="header-anchor" href="#docker" aria-hidden="true">#</a></h1><h3 id="命令" tabindex="-1">命令 <a class="header-anchor" href="#命令" aria-hidden="true">#</a></h3><ul><li><p>pull 拉取镜像</p></li><li><p>images 查看本地镜像</p></li><li><p>search 查找镜像</p></li><li><p>commit 提交容器副本 -m：提交的描述信息 -a：指定镜像作者</p></li><li><p>tag 为镜像增加标签</p></li><li><p>network create 创建一个docker网络 -d：网络类型bridge或overlay；network ls 查看网络列表</p></li><li><p>build 构建镜像 -t：指定镜像名称 后续跟Dockerfile文件目录</p></li><li><p>run 运行容器</p></li><li><p>logs 查看容器内输出</p></li><li><p>start/stop/restart 启动/停止/重启 容器</p></li><li><p>attach/exec 进入容器，区别在于attach在退出终端时会停止容器，推荐使用exec</p></li><li><p>import /export 导入/导出容器</p></li><li><p>rm/rmi 删除 容器/镜像</p></li><li><p>ps 查看所有运行中的容器 -a：查看所有状态的容器 -l：查看最后一次创建的容器</p></li><li><p>port 查看容器的端口映射</p></li></ul><h3 id="run参数" tabindex="-1">run参数 <a class="header-anchor" href="#run参数" aria-hidden="true">#</a></h3><ul><li>-i 可与容器进行交互</li><li>-t 在容器内指定终端</li><li>-d 后台运行</li><li>-P 使用容器内的随机端口映射到外部主机</li><li>-p host:container 指定主机到容器的端口映射</li><li>--name 指定容器名称</li><li>--network 指定网络</li><li>--rm 容器退出时，自动清理容器内的文件系统</li><li>-h HOSTNAME --hostname=HOSTNAME 设定容器的主机名</li><li>--dns=IP_ADDRESS 添加 DNS 服务器到容器 --dns-search=DOMAIN： 设定容器的搜索域</li></ul><h3 id="dockerfile文件" tabindex="-1">Dockerfile文件 <a class="header-anchor" href="#dockerfile文件" aria-hidden="true">#</a></h3><div class="language-docker"><button title="Copy Code" class="copy"></button><span class="lang">docker</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#F78C6C;">FROM</span><span style="color:#A6ACCD;"> ubuntu</span></span>
<span class="line"><span style="color:#F78C6C;">COPY</span><span style="color:#A6ACCD;"> hom* /mydir/</span></span>
<span class="line"><span style="color:#F78C6C;">VOLUME</span><span style="color:#A6ACCD;"> [</span><span style="color:#C3E88D;">&quot;&lt;路径1&gt;&quot;</span><span style="color:#A6ACCD;">, </span><span style="color:#C3E88D;">&quot;&lt;路径2&gt;&quot;</span><span style="color:#A6ACCD;">...]</span></span>
<span class="line"><span style="color:#F78C6C;">WORKDIR</span><span style="color:#A6ACCD;"> &lt;工作目录路径&gt;</span></span>
<span class="line"><span style="color:#F78C6C;">ENTRYPOINT</span><span style="color:#A6ACCD;"> [</span><span style="color:#C3E88D;">&quot;nginx&quot;</span><span style="color:#A6ACCD;">, </span><span style="color:#C3E88D;">&quot;-c&quot;</span><span style="color:#A6ACCD;">] # 定参</span></span>
<span class="line"><span style="color:#F78C6C;">CMD</span><span style="color:#A6ACCD;"> [</span><span style="color:#C3E88D;">&quot;/etc/nginx/nginx.conf&quot;</span><span style="color:#A6ACCD;">] # 变参 </span></span>
<span class="line"><span style="color:#F78C6C;">RUN</span><span style="color:#A6ACCD;"> echo foo &gt; bar</span></span>
<span class="line"><span style="color:#F78C6C;">EXPOSE</span><span style="color:#A6ACCD;"> &lt;端口1&gt; [&lt;端口2&gt;...]</span></span>
<span class="line"></span></code></pre></div><p><strong>FROM</strong> 指定运行的镜像</p><p><strong>RUN/CMD</strong> 用于执行命令，RUN在docker build时运行，CMD 在docker run 时运行</p><p><strong>ENTRYPOIN</strong> 类似CMD，在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。仅最后一个生效</p><p><strong>COPY/ADD</strong> 复制命令，从本机文件复制到容器内的路径。ADD会讲压缩文件解压到目标路径，无法复制压缩文件，可能会使构建比较慢</p><p><strong>VOLUME</strong> 定义匿名数据卷，避免数据因为重启而丢失和容器不断变大</p><p><strong>WORKDIR</strong> 指定工作目录</p><p><strong>EXPOSE</strong> 声明端口</p>`,14),p=[o];function t(r,i,c,d,C,h){return n(),l("div",null,p)}const g=s(e,[["render",t]]);export{D as __pageData,g as default};
