# 数据库

### 引擎
| 名称  | 特点 | `事务\外键` | 锁粒度 | 并发性 | 用途 |
| ------------- | ------------- | ------------- | ------------- | ------------- |------------- |
| InnoDB  | 5.1之前的默认引擎  | 不支持    | 表级锁<br >加锁比较快，锁冲突比较少，不太容易发生死锁的情况    | 差 | 查询多，改动少。数据完整性要求不高 |
| MyISAM  | 5.1之后的默认引擎  | 支持  | 行级锁<br >会发生死锁的情况  | 好 | 用到主外键，要求并发，完整性要求高 |



### 索引

| 类型 | 特点 |
| ------------- | ------------- |
| 全局索引FULLTEXT | 只有 MyISAM 引擎支持全局索引，它的出现是为了解决针对文本的模糊查询效率较低的问题，并且只限于 CHAR、VARCHAR 和 TEXT 列 |
| HASH索引 | 适用于单个键快速查找，但是对于范围查询，性能会较低 |
| B-Tree索引 | 相对高效查询，单个以及范围，B表示平衡 |
| R-Tree索引 | 比较少使用，特别适合返回查询 |



### 多版本并发控制MVCC
保存每条记录的两个隐藏列：创建标志、过期标志，或者说是系统版本号。每开始一个事务，版本号递增。事务开始时的版本号作为当前事务版本号。

插入数据时，当前版本号保存至开始标志。

更新数据时，相当于插入一条新纪录，并将当前版本号保存至开始标志，将原纪录标记为删除，并将新纪录的开始标志保存至过期标志。

删除数据时，当前版本号保存至过期标志。

在REPEATABLE READ隔离级别下，所有查询的数据必须满足两条件:

1. 创建标志小于等于当前版本号，即事务开始前已存在的数据或本事务创建的数据
2. 过期标志大于当前版本号或未定义，保证当前事务开始时，数据未被删除

**MVCC只适用于读已提交（Read committed）和可重复读（Repeatable Read），读未提交只取最新数据，串行化会对所有读取的行加锁。**



### 知识点  

1.  or和in在性能上并不等价，in会先将列表内的数据进行排序，如果字段命中索引，则进行二分查找来确定是否满足条件，复杂度为O(log n)。而单纯的or则是挨个比较，复杂度为O(n)。所以，如果大量比较的时候，用in比较合适。
2.  coalesce(a,b,c);a,b,c以此判断null，返回第一个不为null的值。
3.  GROUP BY xx WITH ROLLUP，分组后再次汇总，类似于excel底部求和。
4.  InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚
5.  预写式日志(Write-Ahead Logging)，先修改数据的内存拷贝，再把修改行为记录到事务日志中，后台再慢慢刷回到磁盘。
