# MYSQL

#### 引擎
| 名称  | 特点 | 事务外键 | 锁粒度 | 并发性 | 用途 |
| ------- | ------------- | ------------- | ------------- | ------- |------------- |
| InnoDB  | 5.1之前  | 不支持    | 表级锁<br >加锁比较快，锁冲突比较少，不太容易发生死锁的情况    | 差 | 查询多，改动少。数据完整性要求不高 |
| MyISAM  | 5.1之后  | 支持  | 行级锁<br >会发生死锁的情况  | 好 | 用到主外键，要求并发，完整性要求高 |



#### 索引

| 类型 | 特点 |
| ------------- | ------------- |
| 全局索引FULLTEXT | 只有 MyISAM 引擎支持全局索引，它的出现是为了解决针对文本的模糊查询效率较低的问题，并且只限于 CHAR、VARCHAR 和 TEXT 列 |
| HASH索引 | 适用于单个键快速查找，但是对于范围查询，性能会较低 |
| B-Tree索引 | 相对高效查询，单个以及范围，B表示平衡 |
| R-Tree索引 | 比较少使用，特别适合返回查询 |

#### 聚簇索引

1. 是一种数据存储方式，而不是类型。
2. “聚簇”标识数据行和相邻的键值储存在一起。
3. 一个表只能有一个聚簇索引。InnoDb通常是主键，无主键则用非空唯一索引，无索引则隐式定义一个主键。
4. 二级索引查找主键值，在用主键值在聚簇索引中查找实际的行数据。

#### 优化
##### explain结果type的含义

| 类型 | 特点 |
| ------------- | ------------- |
| **system**    | 表只有一行，对于查询中的任何常量表达式都将仅执行一次 |
| **const**     | 在查询中，表最多只有一个匹配行，因为只有一个匹配行，MySQL优化器将在优化阶段读取此行 |
| **eq_ref**    | 对于每个索引键值，表中只有一行匹配。常见于使用唯一索引的连接查询 |
| **ref**       | 此访问类型比`eq_ref`更通用，对于索引键值，可能会有多个匹配行。常见于使用非唯一索引或连接查询中的非唯一索引 |
| **range**     | 只检索给定范围内的行，例如使用<或>查找范围的行 |
| **index**     | 表示查询使用了索引进行全表扫描，但只使用了索引的部分 |
| **all**       | 表示查询执行了全表扫描，没有使用索引，将遍历表的每一行 |

排序从最好到最差


#### 多版本并发控制MVCC
保存每条记录的两个隐藏列：创建标志、过期标志，或者说是系统版本号。每开始一个事务，版本号递增。事务开始时的版本号作为当前事务版本号。

插入数据时，当前版本号保存至开始标志。

更新数据时，相当于插入一条新纪录，并将当前版本号保存至开始标志，将原纪录标记为删除，并将新纪录的开始标志保存至过期标志。

删除数据时，当前版本号保存至过期标志。

在REPEATABLE READ隔离级别下，所有查询的数据必须满足两条件:

1. 创建标志小于等于当前版本号，即事务开始前已存在的数据或本事务创建的数据
2. 过期标志大于当前版本号或未定义，保证当前事务开始时，数据未被删除

**MVCC只适用于读已提交（Read committed）和可重复读（Repeatable Read），读未提交只取最新数据，串行化会对所有读取的行加锁。**



#### 知识点  

1.  or和in在性能上并不等价，in会先将列表内的数据进行排序，如果字段命中索引，则进行二分查找来确定是否满足条件，复杂度为O(log n)。而单纯的or则是挨个比较，复杂度为O(n)。所以，如果大量比较的时候，用in比较合适。
2.  coalesce(a,b,c);a,b,c以此判断null，返回第一个不为null的值。
3.  GROUP BY xx WITH ROLLUP，分组后再次汇总，类似于excel底部求和。
4.  InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。
5.  预写式日志(Write-Ahead Logging)，先修改数据的内存拷贝，再把修改行为记录到事务日志中，后台再慢慢刷回到磁盘。
6.  可以使用COMPRESS函数压缩字符串以减少占用空间，还原时使用CONVERT(UNCOMPRESS(compressed_content) USING utf8)。
