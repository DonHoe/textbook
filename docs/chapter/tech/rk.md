# 软考-软件设计师
## 计算机系统
- 校验码
  - 奇偶校验码 检查奇数\偶数的**个数** 实现**检错**  
  - 海明码 通过扩大码距实现**检错和纠错** 数据n位 校验n位 则  
    $2^k-1 \geq n+k$  
  - 循环冗余校验码CRC 总位数n 数据位k 校验位r 则  
    $n=k+r$
- 可靠性
  - 串联：$R_1*R_2*R_3$
  - 并联：$1-(1-R_1)*(1-R_2)*(1-R_3)$
- RISC和CISC
  - RISC **指令长度固定，硬布线，组合逻辑控制、多寄存器，流水线** 
- 中断方式
  - 程序查询只能**串行**  
## 程序设计语言
- 控制结构：顺序结构、选择结构、控制结构
- 编译与解释
  - 词法、语法、语义分析不可省略
    - 词法分析 逐个字符扫描 输出二元组单词记号流 
    - 语法分析 判断单词符号序列是否符合语法规则 输出语法树  
    - 语义分析 类型分析和检查 找出**静态**语义错误
  - 中间代码生成、代码优化可省略 
    - 中间代码生成 与具体机器**无关** 常用**后缀式**、**三地址码** 、**三元式**、**四元式**、**树(图)**
    - 目标代码生成 与具体的**工作机器密切相关** **寄存器的分配相关**
  - 符号表参与所有阶段，收集记录**符号类型和特征信息**
- **正规式** 用于描述字符串集合的符号表示法
  - `a`表示字符a
  - `a*`表示0或多个字符a 
  - `a|b`表示字符a或者字符b
  - `(ab)*`表示0或多个字符ab组合
- **正规集** 有正规式定义的字符串集合
  - 闭合性 对并、交、补等操作是封闭的
  - 可判定性 对于任何给定的正规集，存在可以有效地判断一个字符串是否属于该集合的算法，通常通过有限状态自动机（FSA）实现
  - 简洁性 正规集可以通过正规式进行简洁描述。
- 有限自动机 **词法分析工具**
- 上下文无关文法 **表示语法规则**
- 中缀式、后缀式（逆波兰式），利用**栈**求值
## 数据结构
- 算法时间复杂度  
  $O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$
- 算法空间复杂度 占用额外的空间 一般为$O(1)$ $O(n)$ $O(n^2)$  
- 渐进符号 $O$记号为上界 $\Omega$记号为下界 $\Theta$记号为紧致界  
  $\Omega < \Theta < O$  
- **递归式** 主定理
  - $T(n) = aT(a/b) + f(n)$ 记住**关键公式** $n^{log_ba}$  
  - 若有常数k,有$f(n)=O(^{log_b{a-k}})$,则$T(n)=\Theta(n^{log_ba})$  
  - 若$f(n)=\Theta(n^{log_ba}lg^kn)$,则$T(n)=\Theta(n^{log_ba}lg^{k+1}n)$ 
- **线性表**
  - 顺序存储 移动元素的个数期望值：插入$E_{insert} = \frac{n}{2}$，删除$E_{delete} = \frac{n-1}{2}$
  - 链式存储  
- **队列** 公式$(Q.front + Q.size -1 + M) \bmod M == Q.rear$  
- **串** 有字符构成的线性表
  - 朴素模式匹配 最好$O(1)$ 最坏$O(n*m)$ 平均$O(n+m)$  
    次数分别为m次 、n-m+1)*m 、(n+m)/2  
- **矩阵** 
  - 上下三角矩阵压缩存储 i>j 则 $k=[\frac{i(i+1)}{2}+j+1]$ 
  - n阶三对角矩阵  存一维数组[k] $k=2i+j-2$
  - 稀疏矩阵 三元组顺序表 十字链式存储
- **树** 
  - 树的度是子节点数量的最大值
  - 节点总数=节点的度数之和加1 
  - 度为m的树中第i层上最多有$m^{i-1}$个节点
  - 高度为h度为m的树上最多有$\frac{m^h-1}{m-1}$ 
  - n个节点度为m的树上最小高度为$log_m(n(m-1)+1)$
- **二叉树**  
   - 第i层最多有$2^{i-1}$个节点
   - 高度为k的节点最多有$2^k-1$个节点
   - 对于任何二叉树，叶子节点数为$n_0$，度为2的节点数为$n_2$，则$n_0=n_2+1$
   - 具有n个节点的完全二叉树，其深度为$(log_2n)+1$
   - 有中序才能构造出二叉树 
   - 平衡二叉树，任意节点左右高差不超过1
   - 二叉排序树 **左<根<右** 中序序列**有序**
   - 最优二叉树 哈夫曼树 n个叶子节点的带权路径长度最小
    - 基于**贪心策略** 总结点数$2n-1$ 
    - 哈夫曼编码压缩比 $\frac{等长*权-带权路径和}{等长*权}$ 
- **图** 
  - 完全图 顶点数n 无向的边数$\frac{n(n-1)}{2}$ 有向图边数$n(n-1)$ 
  - 顶点的边数叫做度 
  - 连通图 无向图中任意两个顶点是连通的 最少边数$n-1$ 最多$\frac{n(n-1)}{2}$
  - 强连通图 有向图中任意两个顶点带方向连通的  最少边数$n$ 最多$n(n-1)$
  - 邻接矩阵表示法（稠密） 邻接链表表示法（稀疏）
  - 拓扑序列：1、取入度为0的顶点 2、删除改顶点的边 3、循环直到没顶点
- **小顶堆大顶堆** 
  - 小:$k_i \leq k_{2i} 且 k_i \leq k_{2i+1}$ 
  - 大:$k_i \geq k_{2i} 且 k_i \geq k_{2i+1}$ 
- **排序** 适用基本有序的数组
  - 直接插入排序  把第i个大的元素插入i位置，依次右移  
    稳定，复杂度:平均$O(n^2)$最坏$O(n^2)$最好$O(n)$空间$O(1)$
  - 计数排序 使用元素范围固定  先统计个元素数量，再重新生成数组
  - 简单选择排序 找到第i个大的元素，并与当前i位置的元素交换位置  
    不稳定，复杂度:平均$O(n^2)$最坏$O(n^2)$最好$O(n^2)$空间$O(1)$
  - 堆排序  即构建大\小顶堆  
    不稳定，复杂度:平均$O(nlog_2n)$最坏$O(nlog_2n)$最好$O(nlog_2n)$空间$O(1)$
  - 冒泡快速  两两相比，交换顺序，不断比出最大最小值  
    稳定，复杂度:平均$O(n^2)$最坏$O(n^2)$最好$O(n)$空间$O(1)$
  - 快速排序 分治 以基准元素分前后来递归  
    不稳定，复杂度:平均$O(log_2n)$最坏$O(n^2)$最好$O(nlog_2n)$空间$O(log_2n)$
  - 归并排序 分治分解=>合并 基本有序时比较次数比较少  
    稳定，复杂度:平均$O(nlog_2n)$最坏$O(nlog_2n)$最好$O(nlog_2n)$空间$O(n)$
## 知识产权
- 著作权 
  - 人身权 发表权（**有时间限制**）、署名权、修改权、保护作品完整权
  - 财产权 复制权、发行权等等
  - 地域性 只保护本国内
- 软件著作权
  -  依据 **中华人民共和国著作权法**和**计算机保护条例**
  -  保护程序（包含原码）和文档  50年
  -  完成创作时就产生
  -  职务开发的作品著作权归属单位，开发人员只享有**署名权**
  -  委托开发 有合同按合同来，无合同归开发者
  -  专利权 **申请**（先到先得，同到协商）
  -  商业秘密 保护**技术信息**、**经营信息**
  -  商标权 归**注册人** 可无限延长 冲突则抽签
## 数据库
- 数据模型
  - 概念数据模型 E-R 按用户观点建模
    - 实体 客观存在的事物
    - 属性 描述实体的属性
    - 码 实体的唯一标识
    - 域 属性的取值范围
    - 联系 实体间的对应关系 1对1、1对n、n对n
  - 结构数据模型
    - 层次模型 **有向树**
    - 网状模型 **图** 
    - 关系模型 **二维表**
- 三级模式结构
  - 概念模式 **基本表**
  - 外模式 **视图**
  - 内模式 **存储文件** 
  - 模式->内模式
  - 外模式->模式
  - 物理独立性 改动模式<->内模式
  - 逻辑独立性 改动模式<->外模式
- 关系代数
  - $\theta$连接-比较、等值连接、自然连接（属性**等值**并去重）
- 关系模式
  - 自反律 若$Y \subseteq  X \subseteq  U$ 则 $X \to Y$为$F$所蕴含
  - 增广律 若$X \to Y$为$F$所蕴含 且$Z \subseteq U$ 则 $XZ \to YZ$为$F$所蕴含
  - 传递律 若$X \to Y,Y \to Z$为$F$所蕴含 则 $X \to Y$为$F$所蕴含
- 范式
  - 第一范式 1NF 原子性 **属性**不能继续分割 存在部分函数依赖数据冗余和更新问题 
  - 第二范式 2NF 非主属性完全依赖于候选码（**主键**）  **无部分依赖**候选码
  - 第三范式 3NF 在2NF上**消除依赖传递**
  - BC范式 BCBF 
  - 第四范式 4NF
- 关系分解
  - 无损联接 $R1 \Join R2$后与原关系内的元素相同则无损 
  - 保持函数依赖 分解后的关系仍能推导出原关系内的元素
- 数据库分析 
  - 需求分析阶段 
    - 确定**系统边界**
    - 产出 **需求说明文档**、**数据流程**、**数据字典**、说明性表格、统计输出表、系统功能结构图
  - 概念设计阶段
    - 依赖需求分析阶段的输出
    - 步骤：抽象数据、设计局部视图、合并消除冲突、修改重构消除冗余
    - 合并时的冲突类型：属性冲突、命名冲突、结构冲突
    - 优化方法：实体类型合并、冗余属性消除、冗余联系消除
  - 逻辑结构设计
    - 转换为数据模型、关系规范化、模式优化、设计用户子模式  
  - E-R图
    - 弱实体  依赖于实体存在的实体 
    - 简单属性(椭圆) 原子的、不可再分的
    - 复合属性 地址（可分省市区）
    - 单值属性 学生的学号 人的身份证号
    - 多值属性(双椭圆) 人的亲属  老师的学生
    - NULL属性 表无意义或者不知道
    - 派生属性(虚线椭圆) 出生日期到年龄 参加工作时间到工作年限 
- 分布式
  - 分片透明 无需知道如何分片存储
  - 复制透明 无需知道复制技术
  - 位置透明 无需知道数据存放的物理位置
  - 逻辑透明 无需知道使用的哪种数据模型
  - 共享性-不同节点数据共享、自治性-每个节点独立管理、可用性-单独节点瘫痪不影响整体、分布性-节点在不同地方存储
## 面向对象技术
- 基础
  - 面向对象=对象+分类+继承+通过消息的通信 
  - 分析阶段（认组互操）：认定对象->组织对象->描述对象间的相互作用->确定对象的操作->定义对象内部信息
  - 实体类（现实中的实体）、接口类（与系统的交互方式）、控制类
  - 多态 参数（**最纯**）、包含（**子类型化**）、过载（**上下文**）、强制
  - 动态绑定（**运行时**）、静态绑定（**编译时**）
  - 设计原则
    - 单一职责 **仅有一个引起变化的原因**
    - 开放-封闭 **可扩展但不可修改**
    - 里氏替换 **基类出现的地方子类一定可以出现**
    - 依赖倒置 **依赖抽象而不是实现**
    - 接口分离 **依赖抽象而不是具体**
    - 共同封闭/重用 **一个包内的影响 对整个包都封闭/重用**
  - 设计阶段（类属服关包）：识别类及对象->定义属性->定义服务->识别关系->识别包 
  - 面向对象测试：算法层、类层、模板层、系统层
- UML 行为建模
  - 事物、关系、图 
  - 依赖-虚线 关联-实线 聚集-菱形箭头 泛化-实线三角箭头 实线-虚线三角箭头
  - 关联多重度 A类的实例可以对应多少B类的实例
  - 图 序列图和通信图为**交互图**
    - 类图 **静态设计** +public -private #protected ~package
    - 对象图 **某一时刻一组对象以及他们之间的关系** 描述了事物的实例的静态快照
    - 用例图 **展现了用例、参与者以及他们之间的关系** 
      - 泛化 实线空心三角箭头 两端为用例
      - 包含 虚线箭头
    - 序列图（时序图） 强调**消息时间顺序**
      - 返回消息为虚线 
    - 通信图（协作图） 强调**接收发送消息的对象的结构组织**
      - 对象->消息
    - 状态图  状态机（状态、转换、事件、活动） 强调**对象行为的事件顺序**
      - 对反应型对象进行建模 
      - 初态（实心圆）、终态（圆中带点） 
      - entry 入口/进入状态立即执行 exit 出口/退出状态立即执行 do 内部活动 占用优先事件 可中断
      - 源状态---触发事件[监护条件]/动作---目标状态
      - 超状态 多个状态组合
    - 活动图 从一个活动到另一个活动的流程 
      - 合并分叉、并发汇合、监护表达式 
      - 对**工作流**、**操作**建模
    - 构件图（组件图）
      - 静态实现视图 把构件映射为一个或多个类、接口、协作  
      - 圆圈为需接口（圆需） 半圆为供接口
    - 部署图
      - **物理**方面建模  
      - 展现软件与硬件之间的关系
      - 实施阶段使用
- 设计模式 **为了服用成功的设计**
  - 创建型 **生原抽工单**
    - 类 工厂方法
    - 对象 抽象工厂、生成器、原型、单例 
    - 工厂方法 使一个类的实例化延迟到其子类
    - 抽象工厂 创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类
    - 生成器 将复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
    - 原型 用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象
    - 单例 保证一个类只有一个实例
  - 结构型 **适桥组装外享代**
    - 类 适配器
    - 对象 适配器、桥接、组合、装饰、外观、享元、代理 
    - 适配器 将一个类的接口转换为客户希望的另外一个接口
    - 桥接(**Implementor**) 将抽象部分与实现部分分离，使它们可以独立的变化 
    - 组合 将对象组合成树形结构表示“部分-整体”层次，使得用户对单个对象和组合对象的使用具有一致性
    - 装饰器 动态给对象添加一些额外的职责，比生成子类更加灵活
    - 外观 为子系统中的一组接口提供一个一致的界面，定义了一个高层接口，使子系统增加容易使用
    - 享元 使用共享计数有效支持大量细粒度对象，java中的字符串
    - 代理 为其他对象提供一种代理以控制对这个给对象的访问
  - 行为型 
    - 类 解释器、模板方法
    - 对象 责任链、命令、迭代器、终结者、备忘录、观察者、状态、策略、访问者 
    - 责任链 使多个对象都有机会处理请求，避免发送者和接收者的耦合
    - 命令 将请求封装为一个对象，可以用不同的请求对客户惊醒参数化，对请求排队，支持撤销
    - 解释器 使用特定的表示来解释语言中的句子
    - 迭代器 提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示
    - 中介者 用一个中介对象来封装一系列的对象交互，使各个对象不需要显示引用，从而松散耦合，可以单独改变之间的交互
    - 备忘录 在不破坏封装性的前提下捕获一个对象的内部状态，以后可以将对象恢复保存前的状态
    - 观察者 一对多的依赖模式，一个对象的状态改变时，所有依赖他的对象都能收到通知
    - 状态 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类
    - 策略 定义一系列算法，将其一个个封装起来，使得可以相互替换，使得算法可以独立于他们的客户而发生变化
    - 模板方法 定义一个操作中的算法股价，将一些步骤延迟到子类中，使得子类可以不改变算法接口而重新定义该算法
    - 访问者 **accept**表示一个作用于某对象结构中的各元素操作，允许不改变各元素类的前提下定义于这些元素的新操作
## 操作系统
- 顺序执行的特性 **顺序性**、**封闭性**、**可再现性** P减V加
- 并发执行的特性 失去程序的封闭性、程序和机器的执行活动不再一一对应、并发程序间的相互制约性 
- 三态模型 运行->阻塞->就绪->运行 时间片到：运行->就绪
- 信号量 
  - PV操作时，**S的绝对值**为等待的进程数
  - n个进程使用m个资源，**信号量的范围**$-(n-m)到m$
- 死锁 
  - 4个必要条件 **互请不环**：互斥条件、请求保持条件、不可剥夺条件、环路条件
  - m个资源被n个进程共享 每个进程都要求k个资源 而$m \geq n(k-1)+1$则不会出现死锁
  - 进程资源图 先分配再申请
  - 处理死锁
- 分页式存储管理
  - 纯分页存储 页面大小=页内地址 **物理地址=（页号=>物理块号）+ 页内地址**  
  - 段页式存储 计算段（最多）、页（最多）、地址的2进制位数大小
- 缓冲区 T输入事件 M传送事件 C计算事件 n进程数
  - 单缓冲 $(T + M)*n + C$
  - 双缓冲 $T*n + M + C$
- 磁盘调度算法 **先移后转**
  - 先来先服务 FCFS 按顺序
  - 最短寻道时间优先 SSTF 按当前最近的
  - 扫描算法（电梯调度算法） SCAN 按当前最近的方向一直到底，然后反向继续  
  - 循环扫描算法 CSCAN  跟上面类似，只是方向固定即从头开始
- 多级索引结构 直接地址索引 一级间接索引 二级间接索引 **块号数量 =数据块大小 / 地址项大小**
- 位示图 n个二进制对应一个字 **字数 = 磁盘容量 / 物理块大小 /字长**
- IO 用户进程->设备无关软件->设备驱动程序->中断处理程序->硬件
## 结构化开发
- 耦合性 **无数标控外公内**
![耦合](/coupling.png)  
- 内聚性
![内聚性](/cohesion.png)
- 系统文档
  - 开发人员-管理人员 **系统开发文档、开发月报、总结报告、开发计划（预算分配表/PERT图/任务分解表/甘特图）**
  - 测试人员-开发人员 **系统方案说明书、系统开发合同、设计说明书、测试计划**
  - 开发人员-用户 **用户手册、操作指南**
- 数据流图 **功能建模**
  - 顶层数据流图 输入输出
  - 自顶向下 从抽象到具体
- 数据字典
  - 为数据流图中的元素作出说明
  - 数据项式式最小的元素 
- 结构图 包含**模块、调用、数据、控制信息、转接符号**
## 软件工程
- 软件过程
  - CMM 能力成熟度模型
    - 初始级 **混乱、依赖核心任务**
    - 可重复级 **建立基本的管理、复制同类的成功**
    - 已定义级 **文档化、标准化**
    - 已管理级 **详细度量标准、软件过程和产品质量被成员理解和控制**
    - 优化级 **通过来自过程质量的反馈、新观念、新技术，持续改进**
  - CMMI 能力成熟度集成 
    - $CL_0$ 未达到$CL_1$
    - $CL_1$ **将可标识的输入转换为可标识的输出，支持过程域的特定目标**
    - $CL_2$ **已管理过程的制度化、所有工作都被监控控制评审**
    - $CL_3$ **已定义过程的制度化**
    - $CL_4$ **可定量管理过程的制度化，使用测试和质量保证来控制和改进过程域**
    - $CL_5$ **使用量化（统计学）改变和优化过程域**
- 过程模型
    | 模式     | 优点| 缺点             |
    | -------- | ----------------------- | ---------------------- |
    | 瀑布模型 | 简单易懂，适合需求明确且不易变更的项目。<br>各阶段明确，便于管理和控制。         | 不灵活，难以应对需求变更。<br>一旦进入后期阶段，修改成本高。               |
    | 敏捷模型 | 适应性强，能够快速响应需求变更。<br>频繁交付可工作的软件，提高用户满意度。       | 需要团队成员高度协作和沟通。<br>不适合大型、复杂的项目，可能导致缺乏文档。 |
    | 迭代模型 | 允许逐步开发和反馈，便于发现和修复问题。<br>适合需求不明确或可能变化的项目。     | 可能导致频繁的需求变更，影响进度控制。<br>各迭代之间的整合可能复杂。       |
    | 螺旋模型 | 结合了迭代和瀑布的优点，重视风险管理。<br>允许频繁的用户反馈和需求调整。         | 实施复杂，需要较强的项目管理能力。<br >可能导致成本和时间的高消耗。      |
    | V模型    | 强调验证和确认，适合安全性高的项目。<br>各阶段都有明确的测试活动，便于质量控制。 | 仍然是线性的，不够灵活。<br>对需求变更的适应性较差。                       |
    - **需求明确清晰** 选瀑布 需要快速发布一个版本 选增量但**成本高、复杂度高**
    - **需求不明确变化多** 选原型，但**不适合大规模**项目
    - **需求不明确变化多尽快使用** 选迭代
    - **重视风险分析且庞大复杂** 选螺旋 但实施复杂，强管理，成本高
    - **面向对象且支持宠用和集成具有迭代无间隙** 选喷泉效率高， 但阶段没界限，强文档
- 统一过程模型RUP
  - 角色->谁做 制品->做什么 活动->怎么做 工作流->怎么做
  - 阶段里程碑 初始-生命周期目标 精化-生命周期架构 构建-初始运作功能 移交-产品发布
- 敏捷开发
  - 极限编程XP
    - 尽早且持续交付
    - 4价值观**（沟简反勇）**：沟通、简单性、反馈、勇气
    - 5原则： 快速反馈、简单性假设、逐步修改、体长更改、优质工作
    - 12实践：计划游戏、结对编程、集体代码所有制、持续集成、小型发布、隐喻、测试先行、现场客户、编码标准
  - 水晶法Crystal **每个不同的项目都需要一套不同的策略约定方法论**
  - 并列争求法Scrum **30天依次的迭代成为冲刺**
  - 自适应软件开发ASD 
  - 敏捷统一过程AUP **大型上连续、小型上迭代**
    - 建模-实现-测试-部署-配置及项目管理-环境管理   
- 软件需求
  - 功能需求 **做什么、何时做、如何改进升级**
  - 性能需求 **技术性指标响应速度时间**
  - 数据需求 **输入输出的准确性精度流量时间** 
- 系统设计
  - 概要设计 
    - **设计软件系统的总体结构**
    - 划分模块 确定功能 确定模块间的接口
    - 数据结构和数据库设计
      - 概念、逻辑、物理
    - 编写文档
      - 概要设计说明书、数据库设计说明书、用户手册、测试计划 
    - 评审    
  - 详细设计
    - **对每个模块进行详细的算法设计**
    - 模块内的数据结构设计
    - 数据库物理设计
    -  其他设计 代码、界面、输入输出
    -  详细设计说明书
    -  评审
- 系统测试 **需求分析阶段开始测试用例**
 - 意义：发现未被发现的错误；目的：以最少的人力和时间发现错误和缺陷 
   - 测试要贯穿各个阶段
   - 要有专人进行
   - 确定预期结果
   - 包含不合理失效输入
   - 是否做了不该做的事情
   - 要有计划，不可有随意性
   - 保存测试计划、测试用例
   - 精心设计测试用例
 - 集成测试
   - 自顶向下 **增量方法 桩模块 BFS DFS** 
   - 自底向上 **从原子模块 驱动模块**
   - 回归测试 **发生变更后执行**
   - 冒烟测试 **频繁项目评估**
 - 测试方法
   - 静态测试 **不运行代码，人力检查和计算机辅助检查**
   - 动态测试 黑盒和白盒
     - 黑盒 **等价类划分、边界值分析、错误推测、因果图** 
     - 白盒
       - 语句覆盖 每个代码块都路过 **最弱覆盖**
       - 判定覆盖 每个逻辑判断的真值和假值都通过一次
       - 条件覆盖 每个逻辑判定中的**子条件**的真值和假值都通过一次
       - 判定/条件覆盖 子条件的真假+判断条件的真假**都要**
       - 条件组合覆盖 每个判定中的子条件**组合** (YY,YN,NY,NN)
       - 路径覆盖 所有的分支路径都要走一次
   - McCabe度量法
     - 有向图G，有向弧m，节点数n， 环路数$V(G) = m - n + 2$  
- 软件维护 **可理解性、可测试性、可修改性**
  - 正确性维护 改正错误
  - 适应性维护 应对环境变化、新技术
  - 完善性维护 扩充功能、改善性能
  - 预防性维护 适应未来的变化
  - 可靠性 $MTTF/(1 + MTTF)$ MTTF为平均无故障时间
  - 可用性 $MTBF/(1 + MTBF)$ MTBF为平均失效间隔时间
  - 可维护 $1/(1 + MTTR)$ MTTR为平均修复时间
- 沟通性 路径值$\frac{(n-1)n}{2}$
- 软件估算模型
  - COCOMO估算模型 **基本（静态单变量）-中级（静态多变量）-详细**
  - COCOMOII估算模型 **应用组装-早期设计-体系构建**
    - 对象点、功能点、代码行
- 进度管理
  - 甘特图Gantt 
  - PERT图
    - 最早时刻 最迟时刻 松弛时间
    - 关键路径 松弛时间为0的路径 
  - 项目活动图 
    - 关键路径
    - 关键路径长度
- 软件配置
  - 目标 变更标识、变更控制、版本控制、确保变更正确的实现、变更报告
  - 内容 版本管理、配置支持、过程支持、团队支持、变化报告、审计支持、配置状态报告
  - 配置数据库 开发库、受控库、产品库
- 风险管理 **不确定性和损失**
  - 项目、技术、商业 
  - 控制 **辅助制定处理风险的策略**
  - 风险避免 是**最好的控制策略**
  - 风险评估 **定义风险的参照水准**
  - 风险显露度 P是发生**概率** C带来的项目**成本**  $RE = P * C$
- 软件质量
  - 特性 子特性
    - 功能
    - 效率-时间、资源 
    - 易恢复性
- 软件评审
- 容错技术 
  - 结构冗余 静态、动态、混合
  - 信息冗余
  - 时间冗余 
## 信息安全
- 防火墙技术
  - 建立在内外网络边界上的过滤封锁机制 
  - 工作层次越低，效率越高，安全性越高
  - 内网>DMZ>外网
  - 包过滤防火墙 **低水平** **网络层TCP 数据链路层IP** 依据**源地址、目标地址、协议、端口号**
  - 应用代理网关防火墙
  - 代理服务技术 **高水平、难配置、速度慢**
  - DMZ 公用服务器
- 病毒
  - 传播性、隐藏性、感染性、潜伏性、触发性、破坏性
  - 入侵检测：专家系统、模型检测、简单匹配
  - worm蠕虫、Trojan木马、Backdoor后门、Macro宏
  - 木马：冰河
  - 蠕虫：欢乐时光、熊猫烧香、红色代码、爱虫病毒、震网
- 网络安全
  - IPSec为IP报文加密
## 算法
- 分治法
  - 分解->求解->合并
- 回溯法
  - 深度优先
- 分支界限
  - 广度优先   
- 动态规划 **0-1背包**
  - 矩阵连乘  
  - 最优子结构
  - 重叠子问题
- 贪心 **分数背包**
  - 最优子结构  
## 计算机网络 
- 物理层 **中继器、集线器** 集线器是一种特殊的多路中继器
- 数据链路层 **网桥、交换器** 交换器是一种多端口的网桥
- 网络层 **路由器**
- ISO/OSI模型
  ![net](/net_p.png)  
  - **应用层、表示层、会话层** FTP(上传20/控制21) HTTP(80) Telnet SMTP NFS SNMP
  - **传输层** TCP UDP
  - **网络层** IP ICMP ARP RARP  
  - TCP/IP是会话层 
  - POP3-110 SMTP-25 HTTP-80
  - 邮件的多媒体使用MIME
  - ARP地址解析，RARP反地址解析。物理地址到mac地址转换。广播请求，单播响应。
  - DHCP自动分配IP地址 失败则169.254.x.x
- 浏览器
  - 寻址 本地host->本地DNS缓存->本地DNS服务器->根域名服务器  
  - 渲染时 选展示页面再断开连接
- IP地址
  - 全0为网络地址 全1为广播地址
- ping进行网络检测 由近及远 127.0.0.1 -> 本地ip -> 默认网关 -> 远程主机
- 路由 选择路由的策略:选择管理距离短的
  - 动态协议：距离向量路由协议、链路状态路由协议 
  - 直连路由
  - 远程路由
  - 主机路由 255.255.255.255
  - 默认路由 0.0.0.0
  - 持久路由
## 大题
### 数据流图
一般试题上上用 E-外部实体 P-加工 D-数据存储 来表示  
![DFD](/DFD.png)  
- 名词解释
  - 外部实体E：存在与软件之外的人、物体、组织、系统  
  - 数据存储D：存储加工后的输出数据、提供加工前的输入数据
  - 加工P：将输入数据处理后得到输出数据
    - 黑洞 只有输入没有输出
    - 白洞/奇迹 只有输出没有输入 
    - 灰洞 输入数据不足以产生输出数据
  - 数据流 **两端至少有一个加工流**
    - 加工流->加工流
    - **写** 加工流->数据存储
    - **读** 数据存储->加工流
    - **输出** 加工流->外部实体
    - **输入** 加工流->加工流  
- 上下文（顶层）数据流图 =>  0层数据流图
  - 实体E识别、数据存储D识别
  - 数据流补充 
    - 方法1 父图子图数据流平衡
    - 方法2 加工要有输入输出
    - 方法3 加工要符合说明
    - 格式：数据流xx  起点aa 终点bb
### E-R图 关系模式 数据建模
- 问题1 填写实体间的联系 用**菱形**表示 1:1 1:n n:m
- 问题2 填写实体缺失的属性及主外键
### UML
- 类图中的线标识
  - 依赖-有方向的虚线 
  - 关联-标重复度的实线 
  - 聚合-空心菱形箭头 
  - 组合-实心菱形箭头
  - 泛化-实线空心三角箭头
  - 实现-虚线空心三角箭头
- 用例图中用例间的关系 包含（include）、扩展（exclude）、泛化（空心三角）  
### 设计模式
- 代码填入 `implmements` `extends` `abstract` `private` `interface`
## 名词术语
- **开发阶段**
  - 需求分析 确定软件要完成的功能及非功能性要求
  - 概要设计 将需求转化为软件的模块划分，确定模块之间的调用关系
  - 详细设计 将模块进行细化，得到详细的数据结构和算法
