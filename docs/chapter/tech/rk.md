# 软考-软件设计师
## 计算机系统
- 校验码
  - 奇偶校验码 检查奇数\偶数的**个数** 实现**检错**  
  - 海明码 通过扩大码距实现**检错和纠错** 数据n位 校验n位 则  
    $2^k-1 \geq n+k$  
  - 循环冗余校验码CRC 总位数n 数据位k 校验位r 则  
    $n=k+r$
- 可靠性
  - 串联：$R_1*R_2*R_3$
  - 并联：$1-(1-R_1)*(1-R_2)*(1-R_3)$
## 程序设计语言
- 控制结构：顺序结构、选择结构、控制结构
- 编译与解释
  - 词法、语法、语义分析不可省略
    - 词法分析 逐个字符扫描 输出二元组单词记号流 
    - 语法分析 判断单词符号序列是否符合语法规则 输出语法树  
    - 语义分析 类型分析和检查 找出**静态**语义错误
  - 中间代码生成、代码优化可省略 
    - 中间代码生成 与具体机器**无关** 常用**后缀式**、**三地址码** 、**三元式**、**四元式**、**树(图)**
    - 目标代码生成 与具体的**工作机器密切相关** **寄存器的分配相关**
  - 符号表参与所有阶段，收集记录**符号类型和特征信息**
- **正规式** 用于描述字符串集合的符号表示法
  - `a`表示字符a
  - `a*`表示0或多个字符a 
  - `a|b`表示字符a或者字符b
  - `(ab)*`表示0或多个字符ab组合
- **正规集** 有正规式定义的字符串集合
  - 闭合性 对并、交、补等操作是封闭的
  - 可判定性 对于任何给定的正规集，存在可以有效地判断一个字符串是否属于该集合的算法，通常通过有限状态自动机（FSA）实现
  - 简洁性 正规集可以通过正规式进行简洁描述。
- 有限自动机 **词法分析工具**
- 上下文无关文法 **表示语法规则**
- 中缀式、后缀式（逆波兰式），利用**栈**求值
## 数据结构
- 算法时间复杂度  
  $O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$
- 算法空间复杂度 占用额外的空间 一般为$O(1)$ $O(n)$ $O(n^2)$  
- 渐进符号 $O$记号为上界 $\Omega$记号为下界 $\Theta$记号为紧致界  
  $\Omega < \Theta < O$  
- **递归式** 主定理
  - $T(n) = aT(a/b) + f(n)$ 记住**关键公式** $n^{log_ba}$  
  - 若有常数k,有$f(n)=O(^{log_b{a-k}})$,则$T(n)=\Theta(n^{log_ba})$  
  - 若$f(n)=\Theta(n^{log_ba}lg^kn)$,则$T(n)=\Theta(n^{log_ba}lg^{k+1}n)$ 
- **线性表**
  - 顺序存储 移动元素的个数期望值：插入$E_{insert} = \frac{n}{2}$，删除$E_{delete} = \frac{n-1}{2}$
  - 链式存储  
- **队列** 公式$(Q.front + Q.size -1 + M) \bmod M == Q.rear$  
- **串** 有字符构成的线性表
  - 朴素模式匹配 最好$O(1)$ 最坏$O(n*m)$ 平均$O(n+m)$  
    次数分别为m次 、n-m+1)*m 、(n+m)/2  
- **矩阵** 
  - 上下三角矩阵压缩存储 i>j 则 $k=[\frac{i(i+1)}{2}+j+1]$ 
  - n阶三对角矩阵  存一维数组[k] $k=2i+j-2$
  - 稀疏矩阵 三元组顺序表 十字链式存储
- **树** 
  - 树的度是子节点数量的最大值
  - 节点总数=节点的度数之和加1 
  - 度为m的树中第i层上最多有$m^{i-1}$个节点
  - 高度为h度为m的树上最多有$\frac{m^h-1}{m-1}$ 
  - n个节点度为m的树上最小高度为$log_m(n(m-1)+1)$
- **二叉树**  
   - 第i层最多有$2^{i-1}$个节点
   - 高度为k的节点最多有$2^k-1$个节点
   - 对于任何二叉树，叶子节点数为$n_0$，度为2的节点数为$n_2$，则$n_0=n_2+1$
   - 具有n个节点的完全二叉树，其深度为$(log_2n)+1$
   - 有中序才能构造出二叉树 
   - 平衡二叉树，任意节点左右高差不超过1
   - 二叉排序树 **左<根<右** 中序序列**有序**
   - 最优二叉树 哈夫曼树 n个叶子节点的带权路径长度最小
    - 基于**贪心策略** 总结点数$2n-1$ 
    - 哈夫曼编码压缩比 $\frac{等长*权-带权路径和}{等长*权}$ 
- **图** 
  - 完全图 顶点数n 无向的边数$\frac{n(n-1)}{2}$ 有向图边数$n(n-1)$ 
  - 顶点的边数叫做度 
  - 连通图 无向图中任意两个顶点是连通的 最少边数$n-1$ 最多$\frac{n(n-1)}{2}$
  - 强连通图 有向图中任意两个顶点带方向连通的  最少边数$n$ 最多$n(n-1)$
  - 邻接矩阵表示法（稠密） 邻接链表表示法（稀疏）
  - 拓扑序列：1、取入度为0的顶点 2、删除改顶点的边 3、循环直到没顶点
- **小顶堆大顶堆** 
  - 小:$k_i \leq k_{2i} 且 k_i \leq k_{2i+1}$ 
  - 大:$k_i \geq k_{2i} 且 k_i \geq k_{2i+1}$ 
- **排序** 适用基本有序的数组
  - 直接插入排序  把第i个大的元素插入i位置，依次右移  
    稳定，复杂度:平均$O(n^2)$最坏$O(n^2)$最好$O(n)$空间$O(1)$
  - 计数排序 使用元素范围固定  先统计个元素数量，再重新生成数组
  - 简单选择排序 找到第i个大的元素，并与当前i位置的元素交换位置  
    不稳定，复杂度:平均$O(n^2)$最坏$O(n^2)$最好$O(n^2)$空间$O(1)$
  - 堆排序  即构建大\小顶堆  
    不稳定，复杂度:平均$O(nlog_2n)$最坏$O(nlog_2n)$最好$O(nlog_2n)$空间$O(1)$
  - 冒泡快速  两两相比，交换顺序，不断比出最大最小值  
    稳定，复杂度:平均$O(n^2)$最坏$O(n^2)$最好$O(n)$空间$O(1)$
  - 快速排序 分治 以基准元素分前后来递归  
    不稳定，复杂度:平均$O(log_2n)$最坏$O(n^2)$最好$O(nlog_2n)$空间$O(log_2n)$
  - 归并排序 分治分解=>合并 基本有序时比较次数比较少  
    稳定，复杂度:平均$O(nlog_2n)$最坏$O(nlog_2n)$最好$O(nlog_2n)$空间$O(n)$
## 知识产权
- 著作权 
  - 人身权 发表权（**有时间限制**）、署名权、修改权、保护作品完整权
  - 财产权 复制权、发行权等等
  - 地域性 只保护本国内
- 软件著作权
  -  依据 **中华人民共和国著作权法**和**计算机保护条例**
  -  保护程序（包含原码）和文档  50年
  -  完成创作时就产生
  -  职务开发的作品著作权归属单位，开发人员只享有**署名权**
  -  委托开发 有合同按合同来，无合同归开发者
  -  专利权 **申请**（先到先得，同到协商）
  -  商业秘密 保护**技术信息**、**经营信息**
  -  商标权 归**注册人** 可无限延长 冲突则抽签
## 数据库
- 数据模型
  - 概念数据模型 E-R 按用户观点建模
    - 实体 客观存在的事物
    - 属性 描述实体的属性
    - 码 实体的唯一标识
    - 域 属性的取值范围
    - 联系 实体间的对应关系 1对1、1对n、n对n
  - 结构数据模型
    - 层次模型 **有向树**
    - 网状模型 **图** 
    - 关系模型 **二维表**
- 三级模式结构
  - 概念模式 **基本表**
  - 外模式 **视图**
  - 内模式 **存储文件** 
  - 模式->内模式
  - 外模式->模式
  - 物理独立性 改动模式<->内模式
  - 逻辑独立性 改动模式<->外模式
- 关系代数
  - $\theta$连接-比较、等值连接、自然连接（属性**等值**并去重）
- 关系模式
  - 自反律 若$Y \subseteq  X \subseteq  U$ 则 $X \to Y$为$F$所蕴含
  - 增广律 若$X \to Y$为$F$所蕴含 且$Z \subseteq U$ 则 $XZ \to YZ$为$F$所蕴含
  - 传递律 若$X \to Y,Y \to Z$为$F$所蕴含 则 $X \to Y$为$F$所蕴含
- 范式
  - 第一范式 1NF 原子性 **属性**不能继续分割 存在部分函数依赖数据冗余和更新问题 
  - 第二范式 2NF 非主属性完全依赖于候选码（**主键**）  **无部分依赖**候选码
  - 第三范式 3NF 在2NF上**消除依赖传递**
  - BC范式 BCBF 
  - 第四范式 4NF
- 关系分解
  - 无损联接 $R1 \Join R2$后与原关系内的元素相同则无损 
  - 保持函数依赖 分解后的关系仍能推导出原关系内的元素
- 数据库分析 
  - 需求分析阶段 
    - 确定**系统边界**
    - 产出 **需求说明文档**、**数据流程**、**数据字典**、说明性表格、统计输出表、系统功能结构图
  - 概念设计阶段
    - 依赖需求分析阶段的输出
    - 步骤：抽象数据、设计局部视图、合并消除冲突、修改重构消除冗余
    - 合并时的冲突类型：属性冲突、命名冲突、结构冲突
    - 优化方法：实体类型合并、冗余属性消除、冗余联系消除
  - 逻辑结构设计
    - 转换为数据模型、关系规范化、模式优化、设计用户子模式  
  - E-R图
    - 弱实体  依赖于实体存在的实体 
    - 简单属性(椭圆) 原子的、不可再分的
    - 复合属性 地址（可分省市区）
    - 单值属性 学生的学号 人的身份证号
    - 多值属性(双椭圆) 人的亲属  老师的学生
    - NULL属性 表无意义或者不知道
    - 派生属性(虚线椭圆) 出生日期到年龄 参加工作时间到工作年限 
- 分布式
  - 分片透明 无需知道如何分片存储
  - 复制透明 无需知道复制技术
  - 位置透明 无需知道数据存放的物理位置
  - 逻辑透明 无需知道使用的哪种数据模型
  - 共享性-不同节点数据共享、自治性-每个节点独立管理、可用性-单独节点瘫痪不影响整体、分布性-节点在不同地方存储
## 面向对象技术
- 基础
  - 面向对象=对象+分类+继承+通过消息的通信 
  - 分析阶段（认组互操）：认定对象->组织对象->描述对象间的相互作用->确定对象的操作->定义对象内部信息
  - 实体类（现实中的实体）、接口类（与系统的交互方式）、控制类
  - 多态 参数（**最纯**）、包含（**子类型化**）、过载（**上下文**）、强制
  - 动态绑定（**运行时**）、静态绑定（**编译时**）
  - 设计原则
    - 单一职责 **仅有一个引起变化的原因**
    - 开放-封闭 **可扩展但不可修改**
    - 里氏替换 **基类出现的地方子类一定可以出现**
    - 依赖倒置 **依赖抽象而不是实现**
    - 接口分离 **依赖抽象而不是具体**
    - 共同封闭/重用 **一个包内的影响 对整个包都封闭/重用**
  - 设计阶段（类属服关包）：识别类及对象->定义属性->定义服务->识别关系->识别包 
  - 面向对象测试：算法层、类层、模板层、系统层
- UML
  - 事物、关系、图 
  - 依赖-虚线 关联-实线 聚集-菱形箭头 泛化-实线三角箭头 实线-虚线三角箭头
  - 关联多重度 A类的实例可以对应多少B类的实例
  - 图 序列图和通信图为**交互图**
    - 类图 **静态设计** +public -private #protected ~package
    - 对象图 **某一时刻一组对象以及他们之间的关系** 描述了事物的实例的静态快照
    - 用例图 **展现了用例、参与者以及他们之间的关系** 
      - 泛化 实线空心三角箭头 两端为用例
      - 包含 虚线箭头
    - 序列图（时序图） 强调**消息时间顺序**
      - 返回消息为虚线 
    - 通信图（协作图） 强调**接收发送消息的对象的结构组织**
      - 对象->消息
    - 状态图  状态机（状态、转换、事件、活动） 强调**对象行为的事件顺序**
      - 对反应型对象进行建模 
      - 初态（实心圆）、终态（圆中带点） 
      - entry 入口/进入状态立即执行 exit 出口/退出状态立即执行 do 内部活动 占用优先事件 可中断
      - 源状态---触发事件[监护条件]/动作---目标状态
      - 超状态 多个状态组合
    - 活动图 从一个活动到另一个活动的流程 
      - 合并分叉、并发汇合、监护表达式 
      - 对**工作流**、**操作**建模
    - 构件图（组件图）
      - 静态实现视图 把构件映射为一个或多个类、接口、协作  
      - 圆圈为需接口（圆需） 半圆为供接口
    - 部署图
      - **物理**方面建模  
      - 展现软件与硬件之间的关系
      - 实施阶段使用
- 设计模式 **为了服用成功的设计**
  - 创建型 **生原抽工单**
    - 类 工厂方法
    - 对象 抽象工厂、生成器、原型、单例 
    - 工厂方法 使一个类的实例化延迟到其子类
    - 抽象工厂 创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类
    - 生成器 将复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
    - 原型 用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象
    - 单例 保证一个类只有一个实例
  - 结构型 **适桥组装外享代**
    - 类 适配器
    - 对象 适配器、桥接、组合、装饰、外观、享元、代理 
    - 适配器 将一个类的接口转换为客户希望的另外一个接口
    - 桥接(**Implementor**) 将抽象部分与实现部分分离，使它们可以独立的变化 
    - 组合 将对象组合成树形结构表示“部分-整体”层次，使得用户对单个对象和组合对象的使用具有一致性
    - 装饰器 动态给对象添加一些额外的职责，比生成子类更加灵活
    - 外观 为子系统中的一组接口提供一个一致的界面，定义了一个高层接口，使子系统增加容易使用
    - 享元 使用共享计数有效支持大量细粒度对象，java中的字符串
    - 代理 为其他对象提供一种代理以控制对这个给对象的访问
  - 行为型 
    - 类 解释器、模板方法
    - 对象 责任链、命令、迭代器、终结者、备忘录、观察者、状态、策略、访问者 
    - 责任链 使多个对象都有机会处理请求，避免发送者和接收者的耦合
    - 命令 将请求封装为一个对象，可以用不同的请求对客户惊醒参数化，对请求排队，支持撤销
    - 解释器 使用特定的表示来解释语言中的句子
    - 迭代器 提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示
    - 中介者 用一个中介对象来封装一系列的对象交互，使各个对象不需要显示引用，从而松散耦合，可以单独改变之间的交互
    - 备忘录 在不破坏封装性的前提下捕获一个对象的内部状态，以后可以将对象恢复保存前的状态
    - 观察者 一对多的依赖模式，一个对象的状态改变时，所有依赖他的对象都能收到通知
    - 状态 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类
    - 策略 定义一系列算法，将其一个个封装起来，使得可以相互替换，使得算法可以独立于他们的客户而发生变化
    - 模板方法 定义一个操作中的算法股价，将一些步骤延迟到子类中，使得子类可以不改变算法接口而重新定义该算法
    - 访问者 **accept**表示一个作用于某对象结构中的各元素操作，允许不改变各元素类的前提下定义于这些元素的新操作
## 操作系统
- 顺序执行的特性 **顺序性**、**封闭性**、**可再现性** P减V加
- 并发执行的特性 失去程序的封闭性、程序和机器的执行活动不再一一对应、并发程序间的相互制约性 
- 三态模型 运行->阻塞->就绪->运行 时间片到：运行->就绪
- 信号量 
  - PV操作时，**S的绝对值**为等待的进程数
  - n个进程使用m个资源，**信号量的范围**$-(n-m)到m$
- 死锁 
  - 4个必要条件 **互请不环**：互斥条件、请求保持条件、不可剥夺条件、环路条件
  - m个资源被n个进程共享 每个进程都要求k个资源 而$m \geq n(k-1)+1$则不会出现死锁
  - 进程资源图 先分配再申请
  - 处理死锁  
## 大题
### 数据流图
一般试题上上用 E-外部实体 P-加工 D-数据存储 来表示  
![DFD](/DFD.png)  
- 名词解释
  - 外部实体E：存在与软件之外的人、物体、组织、系统  
  - 数据存储D：存储加工后的输出数据、提供加工前的输入数据
  - 加工P：将输入数据处理后得到输出数据
    - 黑洞 只有输入没有输出
    - 白洞/奇迹 只有输出没有输入 
    - 灰洞 输入数据不足以产生输出数据
  - 数据流 **两端至少有一个加工流**
    - 加工流->加工流
    - **写** 加工流->数据存储
    - **读** 数据存储->加工流
    - **输出** 加工流->外部实体
    - **输入** 加工流->加工流  
- 上下文（顶层）数据流图 =>  0层数据流图
  - 实体E识别、数据存储D识别
  - 数据流补充 
    - 方法1 父图子图数据流平衡
    - 方法2 加工要有输入输出
    - 方法3 加工要符合说明
    - 格式：数据流xx  起点aa 终点bb
### E-R图 关系模式
- 问题1 填写实体间的联系 用**菱形**表示 1:1 1:n n:m
- 问题2 填写实体缺失的属性及主外键
### UML
- 类图中的线标识
  - 依赖-有方向的虚线 
  - 关联-标重复度的实线 
  - 聚合-空心菱形箭头 
  - 组合-实心菱形箭头
  - 泛化-实线空心三角箭头
  - 实现-虚线空心三角箭头
- 用例图中用例间的关系 包含（include）、扩展（exclude）、泛化（空心三角）  
### 设计模式
- 代码填入 `implmements` `extends` `abstract` `private` `interface`
## 名词术语
- 二进制数据的表示
  - 原码 最高位是符号位0正/1负，其余为绝对值
  - 反码 正数不变，负数的非符号位取反
  - 补码 正数不变，负数的反码加一
- 浮点数 N=尾数*2^指数
  - 尾数为精度
- 死锁的4个必要条件 互请不环
  - 互斥条件
  - 请求保持条件
  - 不可剥夺条件
  - 环路条件 

- **开发阶段**
  - 需求分析 确定软件要完成的功能及非功能性要求
  - 概要设计 将需求转化为软件的模块划分，确定模块之间的调用关系
  - 详细设计 将模块进行细化，得到详细的数据结构和算法
- **开发模型**
  | 模式     | 优点                                                                             | 缺点                                                                       |
  | -------- | -------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
  | 瀑布模型 | 简单易懂，适合需求明确且不易变更的项目。<br>各阶段明确，便于管理和控制。         | 不灵活，难以应对需求变更。<br>一旦进入后期阶段，修改成本高。               |
  | 敏捷模型 | 适应性强，能够快速响应需求变更。<br>频繁交付可工作的软件，提高用户满意度。       | 需要团队成员高度协作和沟通。<br>不适合大型、复杂的项目，可能导致缺乏文档。 |
  | 迭代模型 | 允许逐步开发和反馈，便于发现和修复问题。<br>适合需求不明确或可能变化的项目。     | 可能导致频繁的需求变更，影响进度控制。<br>各迭代之间的整合可能复杂。       |
  | 螺旋模型 | 结合了迭代和瀑布的优点，重视风险管理。<br>允许频繁的用户反馈和需求调整。         | 不实施复杂，需要较强的项目管理能力。<br >可能导致成本和时间的高消耗。      |
  | V模型    | 强调验证和确认，适合安全性高的项目。<br>各阶段都有明确的测试活动，便于质量控制。 | 仍然是线性的，不够灵活。<br>对需求变更的适应性较差。                       |
